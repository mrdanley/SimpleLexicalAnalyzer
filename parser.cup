/* Simple +/-/* expression language; parser evaluates constant expressions on the fly*/
parser code {:
    // Connect this parser to a scanner!
    scanner s;
    Parser(scanner s){ this.s=s; }
:}

/* define how to connect to the scanner! */
init with {: s.init(); :};
scan with {: return s.next_token(); :};

/* Terminals (tokens returned by the scanner). */
terminal		t_BOOLEAN, t_ELSE, t_IMPLEMENTS, t_PRINTLN, t_VOID, t_MULTIPLICATION;
terminal    t_LESSEQUAL, t_NOTEQUAL, t_ASSIGNOP, t_LEFTPAREN, t_LEFTBRACE,
			t_STRINGCONSTANT, t_BREAK, t_EXTENDS, t_INT, t_READLN, t_WHILE, t_DIVISION, t_GREATER,
			t_AND, t_SEMICOLON, t_RIGHTPAREN , t_RIGHTBRACE, t_BOOLEANCONSTANT, t_CLASS, t_FOR,t_INTERFACE, t_RETURN ,t_PLUS , t_MOD , t_GREATEREQUAL,
			t_OR, t_COMMA, t_LEFTBRACKET, t_INTCONSTANT, t_ID, t_DOUBLE, t_IF, t_NEWARRAY, t_STRING, t_MINUS, t_LESS, t_EQUAL,t_NOT, t_PERIOD,
			t_RIGHTBRACKET,t_DOUBLECONSTANT


/* Non terminals */
non terminal            Program, Decl, VariableDecl, FunctionDecl, ClassDecl;
non terminal            InterfaceDecl, Variable, Type, Formals, StmtBlock, Field;
non terminal            Prototype, Stmt, IfStmt, WhileStmt, ForStmt, BreakStmt;
non terminal            ReturnStmt, PrintStmt, Expr, Lvalue, Constant, Call;

/* Precedences WHAT TO DO FOR UNARYMINUS*/
precedence left t_LEFTBRACKET, t_PERIOD
precedence left t_NOT, t_UNARYMINUS;
precedence left t_MULTIPLICATION, t_DIVISION, t_MOD;
precedence left t_ADD, t_MINUS;
precedence left t_LESS, t_LESSEQUAL, t_GREATER, t_GREATEREQUAL;
precedence left t_EQUAL, t_NOTEQUAL;
precedence left t_AND;
precedence left t_OR;
precedence left t_ASSIGNOP;

start with Program;

/* The grammar rules */
Program   ::= Decl
            | Decl Decl
;
Decl      ::= VariableDecl
            | FunctionDecl
            | ClassDecl
            | InterfaceDecl
;
